.. include:: ../../roles.rst

Ada Access Types
================
This document contains a loose number of notes about access types in Ada. This is a complex topic with 
quite some pitfalls 

Implicit Dereference
--------------------
This is a feature that was introduced in Ada 2012 and is described `In this document <https://www.adacore.com/blog/gem-123-implicit-dereferencing-in-ada-2012>`_
It allows to define reference types which can be passed around and used to access the underlying target. 
Normally, when using an access type, you need to use the ``.all`` attribute to de-reference it [#f1]_ but 
implicit de-reference allows you to use references without using ``.all``.

.. code-block:: ada
  :linenos:
  :caption: Consider the type declaration:

  type LF_Ref (Element : not null access Real) is null record with
    Implicit_Dereference => Element;

This defines an access type ``LF_Ref`` to access variables of type ``Real`` (just another name for a 
``Long_Float``) which implicitly dereferences ``Element``. Now, this is really a record type with 
``Element`` as its single member and discriminant and whenever you use a variable of this type to access 
a ``Real`` value, it will automatically dereference and allows read/write access to its target.


.. code-block:: ada
  :linenos:
  :caption: Example of using such a type:

  type AuxAngleClass is tagged record
    xx : aliased Real := 0.0;
    yy : aliased Real := 0.0;
  end record;

  AA : AuxAngleClass := (xx => 0.0, yy => 0.0);
  R  : LF_Ref := Aux_Angle.xx;

This will give you an access type to ``AA.xx`` but you do not have to use ``.all`` in order to access the 
target value. You can do something like :ada:`R := 12.3;` and 

.. rubric::
---

.. [#f1] This is like using the dereference operator (*) in C/C++.
