---
id: Index
aliases: []
tags:
  - dev,ada
date: 2025-11-27T16:54:41
title: Ada Language
---
# The Ada language - personal scratchpad
This is a mostly un-organized collection of notes I took while learning the language. Or rather, 
re-learning, because I've learned Ada many years ago, but the knowledge faded away over many years of not 
using it.

## Case insensitive language
Everything, identifiers, package names, keywords is case-insensitive in Ada. This leads to a common 
practice of using rather long and often descriptive names for identifiers. While this makes the language 
often seen as verbose, it also means that Ada code is usually well readable and avoids cryptic names for 
identifiers or functions.

## Difference WITH vs USE
In Ada, importing modules (informally known as `packages`) is a two step process. The `WITH` keyword 
makes a package available to the current module. `USE` integrates it into the top level namespace. USE is 
therefore optional and should not always be used, particularly to avoid name conflicts.

Suppose, you have a package `Lib` that defines a method `Foo`. To use it you need to do `WITH Lib` and 
you can then use the method in your code by specifying the fully qualified name `Lib.Foo`. If you, 
however, `USE Lib` you can use `Foo` without prefixing it with its package name. An often seen construct 
in Ada are therefore statements like:`
```ada
WITH Ada.Text_IO; USE Ada.Text_IO
```

* When you WITH and/or USE a package in the spec (.ads file), you do not need to do the same in the 
  implementation (.adb) file of your module.
* The compiler will warn you about unused packages when the `-gnatu` switch has been selected. You can 
  silence this warnings (which are usually harmless) by using `-gnatU` (note the capital U). However, 
  importing too man packages can lead to name conflicts which can result in compilation errors.

## Classes, methods, functions
Ada allows object-oriented design and offers all the tools necessary. You can have classes (records in 
Ada) and methods working on instances of such records. The syntax is, however, different from known OO 
langauges like C++ or Java. Ada does not know the concept of member functions, but it does know the 
concept of dynamic dispatching, inheritance and interfaces. Member functions (method) are, however, 
defined in a different way and are not part of the class (record) itself.
```ada
type Point is tagged record
  x, y, z : Coord;
end Point;

procedure Move_PointX(Self : in Point; delta : Coord) is
begin
  Self.x := Self.x + delta;
end Move_PointX;
```

Here we have a record describing a point in 3d space with 3 coordinates (assume `Coord` is a custom 
floating point type that can only take values valid in our coordinate system). The method `Move_PointX` 
shall translate the x-coordinate of our point. Its signature has two arguments, the first is of type 
`Point` and THIS is what makes the procedure a quasi-member of `Point`. Such methods are called 
**primitives** in Ada slang. The compiler then allows objects of type `Point` to use that procedure like 
a normal member method. You can use `p.Move_PointX(3.0);` to increase x by 3 and this would be exactly 
the same as calling `Move_PointX(p, 3.0)`; in which case you must pass a value for the object to work on. 
When using the dot notation, you do NOT need to specify a value for `Self`, the compiler does that for 
you and this works like the implicit this pointer in C++. The method definition must include it, but the 
compiler will automatically translate method calls. In C++ or Java, the method definition is part of the 
class definition and the compiler will call class methods with an implicit `this`. 

Note also that `Self` is not a mandatory name, it's just convention to use names like `Self` or `This` 
but you can use whatever you want. In Ada, this is called the dispatching parameter and you can use dot 
notation ONLY if the dispatching parameter is the first in the list of arguments.
