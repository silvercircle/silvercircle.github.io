{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Content Index","text":"<p>Note</p> <p>This documentation is WIP. It has only recently been started, so there is not much yet, but it's growing    almost every day. Before trying to install, please read the instructions, particularly    the section about requirements</p>"},{"location":"#what-exactly-is-this-all-about","title":"What exactly is this all about?","text":"<p>It's all about a Neovim configuration. You have probably heard the term dotfiles  which usually describes a set of configuration files for one or more programs. The term dotfiles  comes from a convention used by most UNIX-like operating systems: Configuration files are often hidden  and hidden files start with a dot in their filenames. Hence the name dotfiles.</p> <p>Neovim is no different. Its configuration is normally written in the Lua programming language and \u2014 on  UNIX-like operating systems \u2014 resides under <code>$HOME/.config/nvim</code></p>"},{"location":"#quick-overview","title":"Quick overview","text":"<p>This Neovim configuration is meant to be a general purpose configuration targeting many different use  cases. It supports a wide range of languages out-of-the-box and can be expanded with relative ease.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li> <p>Support for many most common languages. C/C++, C#, Java, Python, TypeScript/JavaScript, Scala, HTML,    CSS, JSON, Lua, Markdown, LaTeX and many more.</p> </li> <li> <p>All supported languages have support for Treesitter and are ready for LSP</p> </li> <li> <p>auto-completion via either blink or nvim-cmp plugins.</p> </li> <li> <p>Various means of managing files inside the editor. NvimTree and Oil are integrated by default.</p> </li> <li> <p>Integrated theme engine that support Treesitter and semantic highlighting. At the moment, it comes with    four different color schemes, based on Gruvbox, Dracula, OneDark and Sonokai. Each scheme has variants    to tweak the background color tone, contrast and color-richness.</p> </li> </ul>"},{"location":"#lsp-setup","title":"LSP setup","text":"<p>This is probably the most important and most complex setup task. While a lot has been pre-configured you  will likely still have to configure quite a few things.</p>"},{"location":"DAP/","title":"DAP (Debug Adapter Protocol)","text":"<p>DAP is for debugging what LSP is for writing code. It's an open protocol that connects editors with  debuggers and allows to perform debugging task from within your editor.</p> <p>Note</p> <p>Currently, the configuration only supports C and C++ debugging via gdb or lldb. However, the  necessary prerequisistes, including DAP-UI, are installed. You must install additional DAP connectors using Mason and configure them in <code>lua/dap/nvim_dap.lua</code></p>"},{"location":"DAP/#c-and-c-debugging","title":"C and C++ debugging","text":""},{"location":"FAQ/","title":"Frequently asked questions","text":""},{"location":"Install/","title":"Installing and initial configuration","text":"<p>These <code>dotfiles</code> are targeted at software development, mainly with LSP and CMP as a completion engine.  Many Plugins are optional and not loaded on startup for quick startup time. This happens all under  control of the lazy plugin manager and should not require additional configuration.</p>"},{"location":"Install/#requirements","title":"Requirements","text":"<ul> <li>Neovim version 0.11 or later. Older versions will not work. You can install this    in a variety of ways, using your local package management, compile from source or using a    prebuilt binary installation. This is, however, not topic in these docs.</li> <li>A working git Installation.</li> <li>A supported terminal. On Windows, I recommend WezTerm, but others will work. On    Linux, kitty is my favorite and macOS users may look into Ghostty    or iTerm2 for best results.</li> </ul>"},{"location":"Install/#first-start","title":"First start","text":"<p>After cloning the repo to <code>~/.config/nvim</code> (or the equivalent on Windows or macOS), you should start Neovim  for the first time with the command: <pre><code>nvim --headless -c 'Lazy! sync' +qa\n</code></pre> This will start Neovim without the UI (<code>--headless</code>), install all the plugins using the plugin manager and  then quit. Usually, this should complete without errors unless your system lacks prerequisites like a  working GIT installation.</p> <p>Note</p> <p>Note that this is ONLY required for a fresh install. Once all plugins are installed, you can launch  Neovim normally without parameters.</p>"},{"location":"Install/#review-settings","title":"Review settings","text":"<p>Please take some time and review the basic settings. They're all found in <code>lua/config.lua</code> and  <code>lua/options.lua</code>. The first file holds non-Vim specific settings like theme options and such while  <code>options.lua</code> defines vim options and some auto commands. Also relevant is <code>init.vim</code> which is still not  100% Lua, bust mostly contains auto commands and a few legacy vimscript functions. Custom keymappings are  all in <code>lua/keymap.lua</code> and <code>lua/plugins/command_center.lua</code>.</p>"},{"location":"Install/#configuring-lsp","title":"Configuring LSP","text":"<p>This will need most of your attention. The configuration is built with manual LSP server installation in  mind. You can use <code>Mason</code> to install servers, but as bare minimum, you have to check the contents of  the <code>vim.g.lsp_server_bin</code> table in <code>config.lua</code>. This defines paths (and filenames ) of the supported LSP  servers and is used in <code>plugins/lsp.lua</code> to setup LSP servers.</p>"},{"location":"Install/#plain-mode","title":"Plain mode","text":"<p>For those who prefer a clean environment (or for quick-editing single files) the plain mode is available.  When active, certain plugins like the file tree are not loaded on startup. They are still available,  but they do not clutter the UI by default and do not take time on startup. The same applies to the  terminal split. The plain mode starts faster and offers a clean UI with just a single window. Most  features (like CMP completion, LSP, Tree-sitter, Mason etc.) are still available and will be activated on  demand.</p> <p>To start plain mode, there are two options: Set the environment variable <code>NVIM_PLAIN</code> or start with <code>--cmd \"let g:want_plain=v:true\"</code> on the command line. The content of the environment variable does not matter, it can be set to anything.  The options to activate the filetree (<code>leader,</code>) or the terminal split (<code>f11</code>) are still available. LSP  will work and CMP will be loaded when you first enter InsertMode. </p>"},{"location":"Install/#keymapping","title":"Keymapping","text":"<p>For the description and configuration options, see this file. There are many custom keyboard  commands available.</p>"},{"location":"Install/#cmp-completion","title":"CMP completion","text":"<p>CMP <code>autocompletion</code> is, by default, disabled in this config. Manual completion is available with <code>C-Space</code>  in Insert mode and the command line. Autocomplete can be enabled by setting  <code>vim.g.config.cmp_autocomplete</code> to true in <code>config.lua</code>. For everything else cmp-related, tweaking the  settings in file <code>lua/plugins/cmp.lua</code> is the only available method.</p>"},{"location":"Keymaps/","title":"Custom key mappings","text":"<p>There are many custom keymappings in this config. The majority is defined in <code>plugins/command_center.lua</code>  forming a command palette which can be activated by <code>A-p</code>. This is similar to the command palette known  in other editors. It shows keymappings and command descriptions, is divided into categories and  searchable like any other Telescope picker.</p> <p>Some essential commands are defined in <code>keymap.lua</code>, particularly those that should always be available  even when the command palette is not (yet) loaded.</p> <p><code>Alt-Cursorkey</code> is used to navigate windows, so <code>A-Left</code> goes to the left window, <code>A-Down</code> to the split  below the current and so on.</p> <p>Key notation is in the Vim format without angle brackets. So <code>leader n</code> means to hit the leader key  followed by <code>n</code>, <code>C-n</code> means <code>Ctrl-n</code> and so on.</p> <p>Some keymaps use the notation of a <code>root directory</code>. This is defined as the project root directory for  the active buffer. To find it, various utility functions are used for a best guess approach. If the  file is under GIT version control, then the <code>GIT root</code> will be used. If it is not, a pattern approach  similar to LSP config will be used to find typical project root patterns. Note that this might fail and  return <code>nil</code> in which case the directory of the active buffer will be used.</p>"},{"location":"Keymaps/#file-pickers-telescope","title":"File pickers (Telescope)","text":"key modes meaning C-p n Select recent file (Telescope oldfiles) C-e n,i Select buffer (loaded or unloaded, Telescope buffers) F8 n Find files in the <code>root</code> directory of the active buffer"},{"location":"Keymaps/#keys-related-to-nvim-tree-or-neotree","title":"Keys related to Nvim-Tree or Neotree","text":"key modes meaning leader , n Toggle the tree on the left side leader r n Find the current file in the tree leader R n Sync the tree with the project root directory of the current  file leader nr n sync tree with the parent folder of the current file"},{"location":"Keymaps/#keys-related-to-the-terminal-frame","title":"keys related to the terminal frame","text":"<p>The terminal split is always opened below the current one. This works as toggle, if it's open, it will be  closed. See the docs of how to avoid opening a terminal on startup.</p> key modes meaning F11 n Toggle the terminal frame at the bottom"},{"location":"Keymaps/#navigating-the-main-areas-aka-split","title":"Navigating the main areas (aka split)","text":"<p>The main window is basically divided into four areas. The file tree on the left side, the main editor  window in the center, a terminal split right below it and an optional outline view on the right side of  the main editor area. There are quick navigation keys to focus these frames as follows:</p> key modes meaning A-1 n,i,t,v Focus the left frame (file tree) A-2 n,i,t,v Focus the main text area A-3 n,i,t,v Open or Focus the symbol outline tree (when available) A-4 n,i,t,v Open or focus the terminal <p>Note that this also works when the editor was started in plain mode without an active file tree and  terminal split.</p>"},{"location":"Keymaps/#various-navigation-helpers","title":"Various navigation helpers","text":"key modes meaning A-Backspace n,i Activate the jumplist (recent edit locations) A-S-Left n,i Go back to previous edit location (like C-o) A-S-Right n,i Go to next edit location (like C-i)"},{"location":"Keymaps/#quickfix-mapping","title":"Quickfix mapping","text":"key modes meaning A-S-Down n,i Next quickfix location A-S-Up n,i Previous quickfix location C-f c n,i Close quickfix split"},{"location":"Keymaps/#various-keys","title":"Various keys","text":"key modes meaning F1 i LSP Symbol hover information S-F1 i LSP parameter (signature) help F4 n,i Save a view of the current file (persistent folds) F5 n,i clear search highlights (also those from hlslens"},{"location":"Keymaps/#format-paragraph","title":"Format paragraph","text":"key modes meaning A-C-w i,n Format paragraph to current text width. Use soft line breaks"},{"location":"Keymaps/#cmp-completion-mapping","title":"CMP (completion) mapping.","text":"<p>These mappings are defined in <code>lua/plugins/cmp.lua</code> which contains all cmp-related configuration.  Standard keybindings are used to activate manual completion (<code>C-Space</code>) and select completion suggestions  (<code>Tab</code>).</p>"},{"location":"LSP/","title":"How to configure LSP","text":"<p>First of all, this configuration is not meant to work out-of-the-box as a full-featured IDE or  something like that. It can, but this needs some additional work. The system has been designed with  flexibility in mind \u2014 to support different ways of installing language servers. It is only tested on  Linux (including WSL)</p> <p>Note</p> <p>The following applies to standard LSP server configurations only. It does not cover Java, Scala or C which are handled by dedicated plugins. The language servers for Java, Scala and  C# can also be installed with Mason though.</p>"},{"location":"LSP/#how-to-install-language-servers","title":"How to install language servers?","text":"<p>In most cases, the <code>Mason</code> plugin will do it as long as you have the prerequisites installed on your  system. Generally, you need a working Python and Node.js with its package manager npm, because many  language servers are written in Javascript and use the Node.js infrastructure. For the Java and Scala  language servers, you'll need fully working environments. At least JDK 17 is required for Java and Scala  language servers. Some language servers must be built from source and will thus require the necessary  tools. One example for such a server is <code>gopls</code>, the language server for the Go programming language.  Installing it requires a working Go installation.</p> <p>To interact with Mason simply issue the command</p> <p>Mason</p> <p>on the command line.</p>"},{"location":"LSP/#how-to-configure-language-servers","title":"How to configure language servers","text":"<p>The file lua/lspdef.lua is the main  source of configuration data. It is processed in <code>lua/lsp/defaults.lua</code> and consists of a large table  defining a list of supported server configurations and a corresponding list of server binary locations.  Additionally, it contains data to configure the locations of the Java and C# language servers. This way  ensures a most flexible system that can use language servers installed in many different ways. You could  install all of them manually without the help of Mason and tell Neovim where to find them.</p>"},{"location":"LSP/#customizing-lspdeflua","title":"Customizing lspdef.lua","text":"<p>You can either edit this file directly or make a copy of it. The latter method will prevent your  configuration from being overwritten when you update these dotfiles from the repository. The copy must be named  <code>lspdef_user.lua</code> and reside in the same directory, next to <code>lspdef.lua</code>. If such a file exists, it will  be loaded instead of <code>lspdef.lua</code>.</p> <p>Each entry in the <code>serverconfigs</code> table is defined as follows: <pre><code>  -- this entry has a custom configuration in lsp/serverconfig/lua_ls.lua\n  [\"lua_ls\"]                = { cfg = \"lsp.serverconfig.lua_ls\", active = true,\n    bin = jp(M.masonbinpath, 'lua-language-server')\n  },\n</code></pre></p> <p>Each entry is a key-value pair where the key is a string corresponding to the server name as defined by  the <code>nvim-lspconfig</code> plugin. The value is a table with the following fields:</p> <pre><code>@field  cfg     string|boolean\n@field  active  boolean\n@field  cmd     string\n</code></pre> <p>The <code>cfg</code> field can be either a string or false. When it is false, the default configuration provided by  the <code>nvim-lspconfig</code> plugin from <code>lspconfig.configs.servername</code> will be used. When it is a string, it must  contain a valid Lua module which must return the configuration. See the examples in  <code>lua/lsp/serverconfig</code>.</p> <p>The <code>cmd</code> field has the same format as the <code>cmd</code> field in a server configuration. It must be a list of strings with  a minimum of one entry. The first value (<code>cmd[1]</code>) is the executable of the language server. Unless it  can be found in your <code>$PATH</code>, it must be specified with a full, absolute path and file name. The remaining  entries contain parameters which are passed to the language server executable.</p> <p>A valid entry would look like the following:</p> <pre><code>cmd = { \"/usr/bin/lua-language-server\", '--logpath=' .. vim.fn.stdpath(\"state\") }\n</code></pre> <p>This has two entries, the executable and one command line argument (--logpath).</p> <p>Notes</p> <ul> <li> <p>Even when using a default config (<code>cfg</code> == false), the definitions in the <code>cmd</code> field will    still be used. You can use this to override start commands for any language server, useful when    your servers are installed in non-standard locations, for example.</p> </li> <li> <p>When not using a default config (<code>cfg</code> specifies a module), it depends whether this    configuration has a <code>cmd</code> field. If it does, this will be used, otherwise, the    <code>serverconfigs[\"server].cmd</code> will be used</p> </li> </ul>"},{"location":"LSP/#supported-languages-and-language-servers","title":"Supported languages and language servers:","text":"<ul> <li> <p>C and C++ using Clangd. It is recommended to install Clangd with your operating system tools like    apt-get or dnf on Linux distributions. Usually, this gives you a working Clang version in your    $PATH.</p> </li> <li> <p>Java via jdtls. This is a very powerful and full-featured language server for the Java language that    supports major build systems like Gradle and Maven. It uses the    nvim-jdtls plugin, so please read the documentation    there. This is not implemented as an ordinary LSP server, instead it uses a file type plugin in    <code>ftplugin/java.lua</code> that does all the setup.</p> </li> <li> <p>C# via nvim-roslyn. This is an alternative to the well-known    OmniSharp, using the new C# devkit language server developed by Microsoft. This is the same language    server that also powers the Visual Studio Code C# toolset and is based on the Roslyn compiler infrastructure.    You can learn more about it. It has limited support for Razor and Blazor pages using the rzls    language server and requires a working <code>dotnet</code> installation on your system.</p> </li> <li> <p>Markdown via marksman. Install it from mason, make sure the path is correct in <code>config.lua</code>.</p> </li> <li> <p>LaTeX via texlab. You can install it manually or via mason.</p> </li> <li> <p>Scala via metals. This uses the nvim-metals plugin.    You have to install Scala, Metals, Coursier and sbt and verify that everything works. Adjust    the path for the metals binary in <code>config.lua</code>. This is probably one of the harder things to setup,    but that's just how it is.</p> </li> <li> <p>Ada via als (Ada language server). This is mostly untested, because I do not use this language. It    requires a working GNAT installation.</p> </li> <li> <p>Python via Basedpyright. This requires npm. Installs via <code>Mason</code>.</p> </li> </ul>"},{"location":"LSP/completion/","title":"Auto-completion","text":"<p>This configuration provides two different auto-completion systems which can be selected via  <code>Tweaks.completion.version</code>. Allowed values are blink and nvim-cmp</p>"},{"location":"LSP/completion/#blinkcmp","title":"Blink.cmp","text":"<p>Blink is a relatively modern completion engine that focuses on performance and easy configuration.  Ideally, it should work well with its defaults, nevertheless, a configuration file is provided.</p>"},{"location":"LSP/completion/#nvim-cmp","title":"Nvim-Cmp","text":"<p>This is the older system, available as an alternative. Its configuration file can be found </p> <p>Note</p> <p>This configuration uses a fork of nvim-cmp called magazine. It is fully compatible to <code>nvim-cmp</code> and can use the same configuration files. It includes some performance optimizations and is compatible with all cmp addons and completion sources.</p>"},{"location":"LSP/completion/#differences-between-blinkcmp-and-nvim-cmp","title":"Differences between blink.cmp and nvim-cmp","text":"<p>Blink.cmp is considered to be more modern and offers better performance when using the rust-based  search implementation. It should als be easier to setup and customize. Feature-wise, Blink.cmp and  nvim-cmp are likely on par with each other. They both offer advanced features like ghost text,  signature help, can work with snippets from various sources and enjoy strong support by 3<sup>rd</sup> parties in  form of completion sources.</p>"},{"location":"LSP/mason/","title":"Mason (plugin)","text":"<p>Mason is a Neovim plugin that downloads, installs and  upgrades LSP servers, DAP Adapters, linters and formatters for many different languages. While it is not  a requirement to use it, it's strongly recommended.</p> <p>Mason is invoked from within Neovim with the command <code>Mason</code>. By default it will install plugins to  <code>stdpath(\"data\")/mason</code>. On Linux, that would be <code>$HOME/.local/share/nvim/mason</code>. Within this directory,  Mason will create various subdirectories of which the <code>bin</code> directory is of particular interest. This is  where the executables of all installed language servers can be found. You can add this to your <code>$PATH</code> or  simply configure it via Lspdef. Mason, by default, uses a registry for  installable packages and can be configured to use 3<sup>rd</sup> party registries for packages that are not  available in the default registry.</p> <p>Using unchecked registries can pose a security hazard. Please understand, that downloading and installing  from sites you cannot fully trust can always result in security breaches. While the default Mason  registry should be relatively safe \u2014 the author does watch it and all language servers are downloaded and  installed from official repositories \u2014 third party registries might be not so well audited.</p>"},{"location":"LSP/roslyn/","title":"Roslyn (C#)","text":"<p>LSP support for C# is difficult and covered by dedicated plugins supporting the Roslyn-based C# Dev Kit  language server by Microsoft. This is a far better solution than  OmniSharp which now seems to be in maintenance mode, no  longer receiving major updates. Since the Roslyn language servers does some non-standard things not  covered by Neovim's LSP client implementation, it's easier to integrate it with an extra plugin.</p>"},{"location":"LSP/roslyn/#requirements","title":"Requirements","text":"<ul> <li>A working installation of Microsoft .NET (aka DotNet).    The command <code>dotnet</code> must be on your <code>$PATH</code> and it should at least be version 8. Find out with <code>dotnet    --version</code>.</li> </ul>"},{"location":"LSP/roslyn/#neovim-plugins-used","title":"Neovim Plugins used","text":"<p>The relevant plugins for C# support on this configuration are the Roslyn  plugin and the Razor language server  plugin. The latter is optional, but recommended if you plan to  edit Razor/Blazor pages in your project. The configuration file for the plugin is  <code>lua/plugins/roslyn.lua</code></p>"},{"location":"LSP/roslyn/#supported-features","title":"Supported features","text":"<ul> <li>Code analysis, diagnostics</li> <li>Formatting (including <code>.editorconfig</code> support)</li> <li>auto-completion, symbol search, including workspace symbols.</li> <li>Semantic highlighting</li> </ul>"},{"location":"LSP/roslyn/#for-installing-the-language-server-you-basically-have-two-options","title":"For installing the language server, you basically have two options","text":"<ul> <li> <p>Install via Mason but this needs a custom Mason registry to be configured. Neither the Roslyn nor the    RZLS server are currently covered by the official Mason registry.</p> </li> <li> <p>Manually install the server, by downloading it from Microsoft's release page</p> </li> </ul> <p>Please refer to the Roslyn plugin documentation for more.</p> <p>Make sure, you configure <code>server_bin[\"roslyn\"]</code> in <code>lspdef.lua</code> with the path of the installed language  server.</p>"},{"location":"LSP/roslyn/#note-for-linux-users","title":"Note for Linux users","text":"<p>The Roslyn language server makes heavy use of Linux' <code>inotify</code> feature. On larger projects with many  files, it might run out of available handles and you would have to tune the following <code>sysctl</code> settings:</p> <pre><code>fs.inotify.max_user_watches\nfs.inotify.max_user_instances\n</code></pre> <p>Increase them from the default values (depends on distribution) as needed.</p>"},{"location":"Plugins/","title":"Plugins","text":"<p>This Neovim configuration uses a large number of plugins. About 50 in total, but not all are always  active or even loaded.</p> <ul> <li> <p>Fzf-Lua - Used for the majority of <code>pickers</code> (file browsers, grep and live grep,       LSP queries and many more.</p> </li> <li> <p>Oil - The famous Neovim file manager that allows you to work with files and       directories The Vim Way.</p> </li> <li> <p>Snacks - This is a collection of plugins covering a vast area of features and       areas. Only a few of them are currently in use by this config.</p> </li> </ul>"},{"location":"Plugins/commandpalette/","title":"The Command Palette","text":"<p>The command palette is some sort of list that will allow you to select from a wide range of commands.  Each command has a description, belongs to a category and has one or more keyboard shortcuts assigned.</p> <p>Commands do not need to be mapped to keyboard shortcuts, which allows you to free keyboard mappings for  more frequently used commands.</p> <p>The commandpicker plugin </p>"},{"location":"Plugins/commandpalette/#here-is-how-it-looks","title":"Here is how it looks","text":"The command palette <p>The command palette is always available via the keyboard shortcut Alt+P.</p> <p>The command palette will be populated once the first file was loaded. Because of the large number of  commands to process, it would add significant startup time, that's why activation is delayed.</p>"},{"location":"Plugins/fzf/","title":"Fzf-Lua Integration","text":"<p>This config uses Fzf-Lua for most of the more complex picker jobs  like grep and most lsp tasks. The more recent snacks picker is used for some  custom pickers and features that are not available in Fzf-Lua.</p> <p>Most of the Fzf-Lua pickers are available from the command palette</p>"},{"location":"Plugins/fzf/#zoxide-history-viewer","title":"Zoxide history viewer","text":"<p>Ctrl+X Z opens your zoxide directory history. This requires a working installation of  Zoxide on your system.</p>"},{"location":"Plugins/nvimtree/","title":"NvimTree","text":"<p>This is one of the popular file-tree plugins for Neovim. It presents the file system as a tree-like  structure, similar to the Windows explorer. It offers standard file operations, but also indicates which  files are open, modified or contain diagnostic messages of interest.</p>"},{"location":"Plugins/oil/","title":"Oil (file manager)","text":"<p>Oil is one of the most popular Neovim plugins. It's a file  manager that works different from others, provided by plugins like NvimTree or similar.</p> <p>Oil handles directories like ordinary vim buffers. To delete a file, simply delete the line, to add one  insert a new line, to rename just edit the file name. Oil does not commit your changes to the file system  until you save the buffer representing the directory and it will ask you whether you really want to do  the changes. So, as long as you do not save the Oil buffer and confirm the changes, nothing is changed on  your file system.</p>"},{"location":"Plugins/oil/#using-oil-in-this-config","title":"Using Oil in this config","text":"<p>The keyboard mapping Ctrl+F8 can be used in any buffer to open Oil with the directory of the file  you're editing set as its base.</p> <p>Additionally, some pickers like the Zoxide picker may offer shortcuts to  open a directory with Oil.</p>"},{"location":"Plugins/oil/#leaving-oil","title":"Leaving Oil","text":"<p>Since oil is an ordinary buffer (just an unlisted one), you don't really have to close it. You can, for  example, use Ctrl+E to select another buffer. Or just open another file by any means. Or go back in  the history by using Ctrl+O or Ctrl+Shift+Left.</p>"},{"location":"Plugins/oil/#configuring-oil","title":"Configuring Oil","text":"<p>The configuration file is in  <code>lua/plugins/oil.lua</code>. Please refer to the plugin documentation fore more information.</p>"},{"location":"Plugins/snacks/","title":"Snacks","text":"<p>Snacks is a collection of modules published as a single, relatively large, plugin. Individual modules can  be enabled or stay disabled.</p> <p>The configuration file can be found in lua/plugins/snacks_setup.lua</p> <p>As of now, the following modules are activated for this config:</p>"},{"location":"Plugins/snacks/#snacksindent","title":"Snacks.indent","text":"<p>Provides indent guidelines, including scope visualization. Can be tweaked via <code>Tweaks.indent</code>. There are  two utility keyboard shortcuts to control this feature:</p> <ul> <li> <p><code>utility key</code> + O toggle all indent guides in all buffers on/off</p> </li> <li> <p><code>utility_key</code> + U toggle the indent guides for the current buffer</p> </li> </ul>"},{"location":"Plugins/snacks/#snackslazygit","title":"Snacks.lazygit","text":"<p>This integrates LazyGit into your Neovim. You must install  LazyGit and make sure, its executable is available in your <code>$PATH</code>. By default, it is bound to the F6 keyboard  shortcut and will open a LazyGit window as a floating popup covering about 90% of your Neovim Window.</p>"},{"location":"Plugins/snacks/#snackspicker","title":"Snacks.picker","text":"<p>The picker is an alternative to Telescope or Fzf-Lua, which this configuration uses as its  primary picker. Snacks is mainly used for some custom pickers and simple UI selection dialogs</p>"},{"location":"Theme/","title":"Theme documentation","text":"<p>This Neovim configuration comes with its own advanced theme engine that offers some special features and  multiple color schemes based on well-known themes. At the moment, other themes may or may not work, but  the goal is to improve this situation. It is possible to completely disable the integrated theme engine  and install theme plugins like on any other Neovim installation.</p>"},{"location":"Theme/#welcome-to-darkmatter","title":"Welcome to Darkmatter","text":"<p>The theme is called Darkmatter and provides the following features:</p> <p>The theme engine supports multiple schemes and can switch between them on-the-fly. Each scheme is a  collection of color palette(s) background colors and style rules. Four schemes are included in  <code>lua/darkmatter/schemes</code>, but more can be added.</p> <ul> <li>Frankengruv - a gruvbox inspired theme</li> <li>Transylvania - Inspired by the famous Dracula color scheme.</li> <li>One Darker - A revival of the One Dark scheme.</li> <li>Dark - a Sonokai inspired dark theme</li> </ul>"},{"location":"Theme/#background-modes","title":"Background modes","text":"<p>The theme supports different background color tones, independent of the color palette. Cold (a cool  medium gray with a slight blue-ish hue), Warm (lower color temperature, slightly red-ish tint),  Deepdark (very dark, almost black background) and OLED, a pitch black background designed to save  battery on modern OLED displays.</p>"},{"location":"Theme/#saturation-brightness-contrast","title":"Saturation / brightness / contrast","text":"<p>Three levels of color saturation. Vivid, Medium and Pastel. Vivid normally uses the natural colors  as defined by the color scheme with high contrast and brightness. Medium and Pastel use de-saturated  colors with lower contrast and brightness. Switching between them</p> <ul> <li> <p>Fully transparent or opaque background - can be changed while Neovim is running.</p> </li> <li> <p>Ability to customize color palettes with plugins</p> </li> <li> <p>Supports highlighting plugins to define your own highlight groups. Useful for plugins not supported by    default.</p> </li> <li> <p>Keyboard shortcuts to change theme settings on the fly. No need to restart Neovim.</p> </li> <li> <p>Treesitter and LSP semantic tokens support. Support for some 3<sup>rd</sup> party syntax plugins is included or    can be added by theme plugins.</p> </li> <li> <p>optionally, sync the background color when using the Kitty terminal.</p> </li> </ul>"},{"location":"Theme/#configuration","title":"Configuration","text":""},{"location":"Tweaking/","title":"Tweaking","text":"<p>Like any Neovim configuration, you can modify this to match your own needs. You can basically edit all  files below the <code>lua</code> directory. The problem with this approach is that you would run into problems when  updating the configuration by pulling changes from the repository. This would either merge them with  changes you have made, overwrite your changes or result in merge conflicts. This is sub-optimal and there  should be a way to tweak the configuration.</p>"},{"location":"Tweaking/#how-the-tweaks-distlua-mechanism-works","title":"How the tweaks-dist.lua mechanism works","text":"<p>The <code>lua/tweaks-dist.lua</code> contains a lot of user-tweakable settings. Most of which are somewhat explained  and commented. However, this file would be overwritten when updating the repo via <code>git pull</code>, so there is  a simple system to prevent this:</p> <ul> <li> <p>Create a copy of <code>tweaks-dist.lua</code> and name it <code>mytweaks.lua</code>. Name is important, all lower case and it    must be in the <code>lua</code> folder. Just place it next to <code>tweaks-dist.lua</code> in the same folder.</p> </li> <li> <p>You can now modify settings in <code>mytweaks</code> and they will override corresponding settings in    <code>tweaks-dist.lua</code>. You can also delete everything you do not want to touch from <code>mytweaks.lua</code> but    leave the <code>-dist</code> alone. The <code>mytweaks.lua</code> is merged with the <code>tweaks-dist</code> at startup and all    settings in <code>mytweaks.lua</code> will overwrite the defaults.</p> </li> </ul> <p>It is important to maintain the file structure. Here is a sample for a valid <code>mytweaks.lua</code> file. It  redefines exactly two settings. First, it activates <code>DEV mode</code> which currently does nothing. Second, it  sets <code>Tweaks.completion.version</code> to \"nvim-cmp\". By default, this is set to \"blink\".</p> <pre><code>local Tweaks = {}\n\nTweaks.DEV = true\nTweaks.completion = {\n  version = \"nvim-cmp\" -- # (1)\n}\nreturn Tweaks\n</code></pre> <p>Note</p> <p>Please note line 1 and 7. Do not change them. When changing values, always use <code>tweaks-dist.lua</code> as a  reference. Do not change to many values at once, it will make it more difficult to find settings  responsible for problems.</p> <p>The most important setting to edit in the tweaks is the <code>lsp</code> table, because this contains all the  paths for the supported LSP server binaries. If you install them with Mason, you should not need to edit  most of them, but remember, the config is only supported on Linux and if you are on Windows (native, not  WSL) or macOS, you'll likely have to fix a lot.</p>"},{"location":"Tweaking/#how-do-i-override-keymaps-or-define-my-own","title":"How do I override keymaps or define my own?","text":"<p>The default key mappings are defined in two places:</p> <ul> <li> <p><code>lua/keymaps/default.lua</code></p> </li> <li> <p><code>lua/plugins/commandpicker_addcommands</code>. This configures the command palette   which also supports keyboard mapping.</p> </li> <li> <p>Additionally, <code>lua/keymaps/user.lua</code> will be loaded when it exists. This uses the <code>pcall</code> mechanism and    allows you to override existing or define your own keyboard mappings. Below is an example of how such    a <code>user.lua</code> file would look like.</p> </li> </ul> <pre><code>local Utils = require('subspace.lib')\nvim.g.setkey('n', '&lt;f5&gt;', function() require(\"oil\").open(Utils.getroot_current()) end, \"Open Oil file manager\")\n</code></pre> <p>This would redefine the mapping that opens the Oil file manager. <code>vim.g.setkey</code> is  just a shortcut for <code>vim.keymap.set</code> and <code>Utils.getroot_current()</code> attempts to find the root directory  for the current project. It is part of the <code>subspace.lib</code> collection of utility functions which is part  of this configuration.</p>"}]}