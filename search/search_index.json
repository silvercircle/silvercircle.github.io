{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Content Index","text":"Note <p>This documentation is WIP. It has only recently been started, so there is not much yet, but it's growing    almost every day.</p>"},{"location":"#what-exactly-is-this-all-about","title":"What exactly is this all about?","text":"<p>It's all about a Neovim configuration. You have probably heard the term dotfiles  which usually describes a set of configuration files for one or more programs. The term dotfiles  comes from a convention used by most UNIX-like operating systems: Configuration files are often hidden  and hidden files start with a dot in their filenames. Hence the name dotfiles.</p> <p>Neovim is no different. Its configuration is normally written in the Lua programming language and \u2014 on  UNIX-like operating systems \u2014 resides under <code>$HOME/.config/nvim</code></p>"},{"location":"#lsp-setup","title":"LSP setup","text":"<p>This is probably the most important and most complex setup task. While a lot has been pre-configured you  will likely still have to configure quite a few things.</p>"},{"location":"Install/","title":"Installing and initial configuration","text":"<p>These <code>dotfiles</code> are targeted at software development, mainly with LSP and CMP as a completion engine.  Many Plugins are optional and not loaded on startup for quick startup time. This happens all under  control of the lazy plugin manager and should not require additional configuration.</p>"},{"location":"Install/#first-start","title":"First start","text":"<p>After cloning the repo to <code>~/.config/nvim</code> (or the equivalent on Windows or macOS), you should start nvim  for the first time with the command: <pre><code>nvim --headless -c 'Lazy! sync' +qa\n</code></pre> This will start Neovim without an UI (<code>--headless</code>) install all the plugins using the plugin manager and  then quit. Usually, this should complete without errors unless your system lacks prerequisites like a  working GIT installation.</p> <p>Note</p> <p>Note that this is ONLY required for a fresh install. Once all plugins are installed, you can launch  Neovim normally without parameters.</p>"},{"location":"Install/#review-settings","title":"Review settings","text":"<p>Please take some time and review the basic settings. They're all found in <code>lua/config.lua</code> and  <code>lua/options.lua</code>. The first file holds non-Vim specific settings like theme options and such while  <code>options.lua</code> defines vim options and some auto commands. Also relevant is <code>init.vim</code> which is still not  100% Lua, bust mostly contains auto commands and a few legacy vimscript functions. Custom keymappings are  all in <code>lua/keymap.lua</code> and <code>lua/plugins/command_center.lua</code>.</p>"},{"location":"Install/#configuring-lsp","title":"Configuring LSP","text":"<p>This will need most of your attention. The configuration is built with manual LSP server installation in  mind. You can use <code>Mason</code> to install servers, but as bare minimum, you have to check the contents of  the <code>vim.g.lsp_server_bin</code> table in <code>config.lua</code>. This defines paths (and filenames ) of the supported LSP  servers and is used in <code>plugins/lsp.lua</code> to setup LSP servers.</p>"},{"location":"Install/#plain-mode","title":"Plain mode","text":"<p>For those who prefer a clean environment (or for quick-editing single files) the plain mode is available.  When active, certain plugins like the file tree are not loaded on startup. They are still available,  but they do not clutter the UI by default and do not take time on startup. The same applies to the  terminal split. The plain mode starts faster and offers a clean UI with just a single window. Most  features (like CMP completion, LSP, Tree-sitter, Mason etc.) are still available and will be activated on  demand.</p> <p>To start plain mode, there are two options: Set the environment variable <code>NVIM_PLAIN</code> or start with <code>--cmd \"let g:want_plain=v:true\"</code> on the command line. The content of the environment variable does not matter, it can be set to anything.  The options to activate the filetree (<code>leader,</code>) or the terminal split (<code>f11</code>) are still available. LSP  will work and CMP will be loaded when you first enter InsertMode. </p>"},{"location":"Install/#keymapping","title":"Keymapping","text":"<p>For the description and configuration options, see this file. There are many custom keyboard  commands available.</p>"},{"location":"Install/#cmp-completion","title":"CMP completion","text":"<p>CMP <code>autocompletion</code> is, by default, disabled in this config. Manual completion is available with <code>C-Space</code>  in Insert mode and the command line. Autocomplete can be enabled by setting  <code>vim.g.config.cmp_autocomplete</code> to true in <code>config.lua</code>. For everything else cmp-related, tweaking the  settings in file <code>lua/plugins/cmp.lua</code> is the only available method.</p>"},{"location":"Keymaps/","title":"Custom key mappings","text":"<p>There are many custom keymappings in this config. The majority is defined in <code>plugins/command_center.lua</code>  forming a command palette which can be activated by <code>A-p</code>. This is similar to the command palette known  in other editors. It shows keymappings and command descriptions, is divided into categories and  searchable like any other Telescope picker.</p> <p>Some essential commands are defined in <code>keymap.lua</code>, particularly those that should always be available  even when the command palette is not (yet) loaded.</p> <p><code>Alt-Cursorkey</code> is used to navigate windows, so <code>A-Left</code> goes to the left window, <code>A-Down</code> to the split  below the current and so on.</p> <p>Key notation is in the Vim format without angle brackets. So <code>leader n</code> means to hit the leader key  followed by <code>n</code>, <code>C-n</code> means <code>Ctrl-n</code> and so on.</p> <p>Some keymaps use the notation of a <code>root directory</code>. This is defined as the project root directory for  the active buffer. To find it, various utility functions are used for a best guess approach. If the  file is under GIT version control, then the <code>GIT root</code> will be used. If it is not, a pattern approach  similar to LSP config will be used to find typical project root patterns. Note that this might fail and  return <code>nil</code> in which case the directory of the active buffer will be used.</p>"},{"location":"Keymaps/#file-pickers-telescope","title":"File pickers (Telescope)","text":"key modes meaning C-p n Select recent file (Telescope oldfiles) C-e n,i Select buffer (loaded or unloaded, Telescope buffers) F8 n Find files in the <code>root</code> directory of the active buffer"},{"location":"Keymaps/#keys-related-to-nvim-tree-or-neotree","title":"Keys related to Nvim-Tree or Neotree","text":"key modes meaning leader , n Toggle the tree on the left side leader r n Find the current file in the tree leader R n Sync the tree with the project root directory of the current  file leader nr n sync tree with the parent folder of the current file"},{"location":"Keymaps/#keys-related-to-the-terminal-frame","title":"keys related to the terminal frame","text":"<p>The terminal split is always opened below the current one. This works as toggle, if it's open, it will be  closed. See the docs of how to avoid opening a terminal on startup.</p> key modes meaning F11 n Toggle the terminal frame at the bottom"},{"location":"Keymaps/#navigating-the-main-areas-aka-split","title":"Navigating the main areas (aka split)","text":"<p>The main window is basically divided into four areas. The file tree on the left side, the main editor  window in the center, a terminal split right below it and an optional outline view on the right side of  the main editor area. There are quick navigation keys to focus these frames as follows:</p> key modes meaning A-1 n,i,t,v Focus the left frame (file tree) A-2 n,i,t,v Focus the main text area A-3 n,i,t,v Open or Focus the symbol outline tree (when available) A-4 n,i,t,v Open or focus the terminal <p>Note that this also works when the editor was started in plain mode without an active file tree and  terminal split.</p>"},{"location":"Keymaps/#various-navigation-helpers","title":"Various navigation helpers","text":"key modes meaning A-Backspace n,i Activate the jumplist (recent edit locations) A-S-Left n,i Go back to previous edit location (like C-o) A-S-Right n,i Go to next edit location (like C-i)"},{"location":"Keymaps/#quickfix-mapping","title":"Quickfix mapping","text":"key modes meaning A-S-Down n,i Next quickfix location A-S-Up n,i Previous quickfix location C-f c n,i Close quickfix split"},{"location":"Keymaps/#various-keys","title":"Various keys","text":"key modes meaning F1 i LSP Symbol hover information S-F1 i LSP parameter (signature) help F4 n,i Save a view of the current file (persistent folds) F5 n,i clear search highlights (also those from hlslens"},{"location":"Keymaps/#format-paragraph","title":"Format paragraph","text":"key modes meaning A-C-w i,n Format paragraph to current text width. Use soft line breaks"},{"location":"Keymaps/#cmp-completion-mapping","title":"CMP (completion) mapping.","text":"<p>These mappings are defined in <code>lua/plugins/cmp.lua</code> which contains all cmp-related configuration.  Standard keybindings are used to activate manual completion (<code>C-Space</code>) and select completion suggestions  (<code>Tab</code>).</p>"},{"location":"LSP/","title":"LSP and auto-completion","text":"<p>This is probably the biggest chunk in the configuration and </p>"},{"location":"LSP/completion/","title":"Auto-completion","text":"<p>This configuration provides two different auto-completion systems which can be selected via  <code>Tweaks.completion.version</code>. Allowed values are blink and nvim-cmp</p>"},{"location":"LSP/completion/#blinkcmp","title":"Blink.cmp","text":"<p>Blink is a relatively modern completion engine that focuses on performance and easy configuration.  Ideally, it should work well with its defaults, nevertheless, a configuration file is provided.</p>"},{"location":"LSP/completion/#nvim-cmp","title":"Nvim-Cmp","text":"<p>This is the older system, available as an alternative. Its configuration file can be found </p> <p>Note</p> <p>This configuration uses a fork of nvim-cmp called magazine. It is fully compatible to <code>nvim-cmp</code> and can use the same configuration files. It includes some performance optimizations and is compatible with all cmp addons and completion sources.</p>"},{"location":"LSP/lsp/","title":"How to configure LSP","text":"<p>First of all, this configuration is not meant to work out-of-the-box as a full-featured IDE or  something like that. It can, but this needs some additional work.</p>"},{"location":"LSP/lsp/#how-to-install-language-servers","title":"How to install language servers?","text":"<p>In most cases, the <code>Mason</code> plugin will do it as long as you have the prerequisites installed on your  system. Generally, you need a working Python and Node.js with its package manager npm, because many  language servers are written in Javascript and use the Node.js infrastructure. For the Java and Scala  language servers, you'll need fully working environments. At least JDK 17 is required for Java and Scala  language servers.</p> <p>You do not have to use <code>Mason</code> though. You can install language servery any way you want and it will  work as long as you tell Neovim where they are by editing the <code>vim.g.lsp_server_bin</code> table in  <code>config.lua</code>.</p>"},{"location":"LSP/lsp/#how-to-configure-language-servers","title":"How to configure language servers","text":"<p>For most, this is done in <code>lua/lsp.lua</code>. See below for a list of supported language servers. You also  have to tell Neovim where the language servers are installed. In <code>lua/config.lua</code>, there is a table  <code>vim.g.lsp_server_bin</code> that holds the paths for all supported servers. Check the Mason documentation  where it will install the language servers. On Linux, this is usually <code>$HOME/.local/share/nvim/mason</code>.</p>"},{"location":"LSP/lsp/#supported-languages-and-language-servers","title":"Supported languages and language servers:","text":"<ul> <li> <p>C and C++ using Clangd. It is recommended to install Clangd with your operating system tools like    apt-get or dnf on Linux distributions. Usually, this gives you a working Clang version in your    $PATH.</p> </li> <li> <p>Java via jdtls. This is a very powerful and full-featured language server for the Java language that    supports major build systems like Gradle and Maven. It uses the    nvim-jdtls plugin, so please read the documentation    there.</p> </li> <li> <p>C# via csharp_ls. This is an alternative to the well-known OmniSharp, based on the Roslyn compiler    infrastructure. You can learn more about it    here. This works with minimal configuration and    requires a <code>dotnet</code> installation on your system.</p> </li> <li> <p>Markdown via marksman. Install it from mason, make sure the path is correct in <code>config.lua</code>.</p> </li> <li> <p>LaTeX via texlab. You can install it manually or via mason.</p> </li> <li> <p>Scala via metals. This uses the nvim-metals plugin.    You have to install Scala, Metals, Coursier and sbt and verify that everything works. Adjust    the path for the metals binary in <code>config.lua</code>. This is probably one of the harder things to setup,    but that's just how it is.</p> </li> <li> <p>Ada via als (Ada language server). This is mostly untested, because I do not use this language. It    requires a working GNAT installation.</p> </li> <li> <p>Python via Pyright. This requires npm, because that is basically the Visual Studio Code python    language server extracted. Installs via <code>Mason</code>.</p> </li> </ul>"},{"location":"Plugins/","title":"Plugins","text":"<p>This Neovim configuration uses a large number of plugins. About 50 in total, but not all are always  active or even loaded.</p> <ul> <li> <p>Fzf-Lua - Used for the majority of <code>pickers</code> (file browsers, grep and live grep,       LSP queries and many more.</p> </li> <li> <p>Oil - The famous Neovim file manager that allows you to work with files and       directories The Vim Way.</p> </li> <li> <p>Snacks - This is a collection of plugins covering a vast area of features and       areas. Only a few of them are currently in use by this config.</p> </li> </ul>"},{"location":"Plugins/commandpalette/","title":"The Command Palette","text":"<p>The command palette is some sort of popup that will allow you to select from a wide range of commands.  Each command has a description, belongs to a category and has one or more keyboard shortcuts assigned.</p>"},{"location":"Plugins/commandpalette/#here-is-how-it-looks","title":"Here is how it looks","text":"The command palette <p>The command palette is always available via the keyboard shortcut Alt+P.</p> <p>The command palette will be populated once the first file was loaded. Because of the large number of  commands to process, it would add significant startup time, that's why activation is delayed.</p>"},{"location":"Plugins/fzf/","title":"Fzf-Lua Integration","text":"<p>This config uses Fzf-Lua for most of the more complex picker jobs  like grep and most lsp tasks. The more recent snacks picker is used for some  custom pickers and features that are not available in Fzf-Lua.</p> <p>Most of the Fzf-Lua pickers are available from the command palette</p>"},{"location":"Plugins/fzf/#zoxide-history-viewer","title":"Zoxide history viewer","text":"<p>Ctrl+X Z opens your zoxide directory history. This requires a working installation of  Zoxide on your system.</p>"},{"location":"Plugins/oil/","title":"Oil (file manager)","text":"<p>Oil is one of the most popular Neovim plugins. It's a file  manager that works different from others, provided by plugins like NvimTree or similar.</p> <p>Oil allows to manipulate directories like ordinary vim buffers. To delete a file, simply delete the line,  to add one insert a new line and so on. Oil does not commit your changes to the file system until you save  the buffer representing the directory and it will ask you whether you really want to do the changes.</p>"},{"location":"Plugins/oil/#using-oil-in-this-config","title":"Using Oil in this config","text":"<p>The keyboard mapping Ctrl+F8 can be used in any buffer to open Oil with the directory of the file  you're editing set as its base.</p> <p>Additionally, some pickers like the Zoxide picker may offer shortcuts to  open a directory with Oil.</p>"},{"location":"Plugins/oil/#leaving-oil","title":"Leaving Oil","text":"<p>Since oil is an ordinary buffer (just an unlisted one), you don't really have to close it. You can, for  example, use Ctrl+E to select another buffer. Or go back in the history by using +Ctrl+O or  Ctrl+Shift+Left.</p>"},{"location":"Plugins/snacks/","title":"Snacks","text":"<p>Snacks is a collection of modules published as a single, relatively large, plugin. Individual modules can  be enabled or stay disabled.</p> <p>The configuration file can be found in lua/plugins/snacks_setup.lua</p> <p>As of now, the following modules are activated for this config:</p>"},{"location":"Plugins/snacks/#snacksindent","title":"Snacks.indent","text":"<p>Provides indent guidelines, including scope visualization. Can be tweaked via <code>Tweaks.indent</code>. There are  two utility keyboard shortcuts to control this feature:</p> <ul> <li> <p><code>utility key</code> + O toggle all indent guides in all buffers on/off</p> </li> <li> <p><code>utility_key</code> + U toggle the indent guides for the current buffer</p> </li> </ul>"},{"location":"Plugins/snacks/#snackslazygit","title":"Snacks.lazygit","text":"<p>This integrates LazyGit into your Neovim. You must install  LazyGit and make sure, its executable is available in your <code>$PATH</code>. By default, it is bound to the F6 keyboard  shortcut and will open a LazyGit window as a floating popup covering about 90% of your Neovim Window.</p>"},{"location":"Plugins/snacks/#snackspicker","title":"Snacks.picker","text":"<p>The picker is an alternative to Telescope or Fzf-Lua, which this configuration uses as its  primary picker. Snacks is mainly used for some custom pickers and simple UI selection dialogs</p>"},{"location":"Theme/","title":"Theme documentation","text":"<p>This Neovim config comes with its own advanced theme that offers some special features. At the moment,  other themes may or may not work, but the goal is to improve this situation.</p> <p>The theme is called Darkmatter and provides the following features:</p> <ul> <li> <p>Three different background tones. Cold (a cool medium gray with a slight blue-ish hue), Warm (lower    color temperature, slightly redd-ish tint) and Deepdark (very dark, almost black background)..</p> </li> <li> <p>Three levels of color saturation. Vivid with high color intensity and contrast and two levels of    desaturated colors.</p> </li> <li> <p>Two selections for string coloring. Green or Yellow.</p> </li> <li> <p>Fully transparent or opaque background - can be changed while Neovim is running.</p> </li> <li> <p>Ability to customize color palettes with plugins</p> </li> <li> <p>Supports highlighting plugins to define your own highlight groups. Useful for plugins not supported by    default.</p> </li> <li> <p>Keyboard shortcuts to change theme settings on the fly. No need to restart Neovim.</p> </li> <li> <p>Treesitter and LSP semantic tokens support. Support for some 3<sup>rd</sup> party syntax plugins is included or    can be added by theme plugins.</p> </li> <li> <p>optionally, sync the background color when using the Kitty terminal.</p> </li> </ul>"},{"location":"Theme/#configuration","title":"Configuration","text":""},{"location":"Tweaking/","title":"Tweaking","text":"<p>Like any Neovim configuration, you can modify this to match your own needs. You can basically edit all  files below the <code>lua</code> directory. The problem with this approach is that you would run into problems when  updating the configuration by pulling changes from the repository. This would either merge them with  changes you have made, overwrite your changes or result in merge conflicts. This is sub-optimal and </p>"},{"location":"Tweaking/#how-the-tweaks-distlua-mechanism-works","title":"How the tweaks-dist.lua mechanism works","text":"<p>The <code>lua/tweaks-dist.lua</code> contains a lot of user-tweakable settings. Most of which are somewhat explained  and commented. However, this file would be overwritten when updating the repo via <code>git pull</code>, so there is  a simple system to prevent this:</p> <ul> <li> <p>Create a copy of <code>tweaks-dist.lua</code> and name it <code>mytweaks.lua</code>. Name is important, all lower case and it    must be in the <code>lua</code> folder. Just place it next to <code>tweaks-dist.lua</code> in the same folder.</p> </li> <li> <p>You can now modify settings in <code>mytweaks</code> and they will override corresponding settings in    <code>tweaks-dist.lua</code>. You can also delete everything you do not want to touch from <code>mytweaks.lua</code> but    leave the <code>-dist</code> alone. The <code>mytweaks.lua</code> is merged with the <code>tweaks-dist</code> at startup</p> </li> </ul> <p>It is important to maintain the file structure. Here is a sample for a valid <code>mytweaks.lua</code> file. It  redefines exactly two settings. First, it activates <code>DEV mode</code> which currently does nothing. Second, it  sets <code>Tweaks.completion.version</code> to \"nvim-cmp\". By default, this is set to \"blink\".</p> <p><pre><code>local Tweaks = {}\n\nTweaks.DEV = true\nTweaks.completion = {\n  version = \"nvim-cmp\" -- # (1)\n}\n\nreturn Tweaks\n</code></pre></p> <p>Note</p> <p>Please note line 1 and 8. Do not change them. When changing values, always use <code>tweaks-dist.lua</code> as a  reference. Do not change to many values at once, it will make it more difficult to find settings  responsible for problems.</p> <p>The most important setting to edit in the tweaks is the <code>lsp</code> table, because this contains all the  paths for the supported LSP server binaries. If you install them with Mason, you should not need to edit  most of them, but remember, the config is only supported on Linux and if you are on Windows (native, not  WSL) or macOS, you'll likely have to fix a lot.</p>"},{"location":"Tweaking/#how-do-i-override-keymaps-or-define-my-own","title":"How do I override keymaps or define my own?","text":"<p>The default key mappings are defined in two places:</p> <ul> <li> <p><code>lua/keymaps/default.lua</code></p> </li> <li> <p><code>lua/plugins/commandpicker_addcommands</code>. This configures the command palette   which also supports keyboard mapping.</p> </li> <li> <p>you can always put additional lua files in <code>lua/keymaps</code> and they will be executed after    <code>defaults.lua</code>, so you can override any default mapping.</p> </li> </ul> <p><pre><code>local Utils = require('subspace.lib')\n\nvim.g.setkey('n', '&lt;f5&gt;', function() require(\"oil\").open(Utils.getroot_current()) end, \"Open Oil file manager\")\n</code></pre> This would redefine the mapping that opens the Oil file manager. <code>vim.g.setkey</code> is  just a shortcut for <code>vim.keymap.set</code> and <code>Utils.getroot_current()</code> attempts to find the root directory  for the current project.</p>"}]}